
/** 
 * * 타입 변환
 * ? 모든 데이터는 효율적인 메모리 관리를 위해 데이터 타입을 가지고 있다.
 * ? 타입을 알기 위해선 일반적으로 typeof를 사용하고 null 같은 특수한 경우에는
 * ? === 연산자를 사용해 알아낼 수 있다. 
 * TODO 이 타입은 다른 타입간의 연산이나 직접 타입을 변환할 경우에 바뀔 수 있다.
 * ? 대표적으로 2가지 타입 변환이 있다.
*/

/** 
 * * 암묵적 타입 변환
 * * 타입 강제 변환
*/

var cas = 23; 

cas += ''; 

console.log(typeof cas); 

/**
 * ? 자바스크립트의 특징 중 하나는 데이터 타입을 사전에 정의하지 않고
 * ? 값을 할당 했을시 그에 따라 알맞은 타입을 할당하는 동적 타이핑 언어이다.
 * ? var 라는 변수에는 어떠한 데이터 타입도 들어갈 수 있기 때문에 다른 타입
 * ? 끼리의 연산이라도 자바스크립트 엔진이 암묵적으로 하나의 타입으로 변환하고 연산한다.
 * ? 위의 예시는 문자열 연결 연산자인 +를 통해 문자열이 하나라도 있으면 숫자 타입을
 * ? 강제로 문자열로 바꾼뒤 이어버린다.
 */


/** 
 * ! 변수의 불변성
 * ? 원시 타입의 변수는 일단 값이 할당되는 그 순간 그 리터럴은 절대 바뀔 수 없는 특징이 있다.
 * ? 따라서 자바스크립트 엔진에 의해 강제로 타입이 바뀌는 것도 원시값이 바뀌는 것이 아닌
 * ? 엔진이 임의로 그의 해당하는 타입의 값을 새롭게 만든 다음에, 그 값을 연산에 사용한 다음 버린다.
 * TODO 강제로 바뀐 타입의 값은 1회성이다. 자세하게는 참조할 수가 없기에 가비지 콜렉터가 메모리를 해제시킨다.
*/

/** 
 * ! 암묵적 타입 변환의 단점
 * ? 암묵이라는건 아무도 모르게 라는 뜻이다. 즉 개발자나 코드를 인수인계 받는 사람 입장에선 타입이 바뀌어버리는 것으로 인해
 * ? 문제가 발생할 수 있다. 위에 당장 cas += ''; 만 봐도 암묵적 타입 변환에 대한 이해가 부족하다면 저게 뭔지 알 수가 없다.
 * ? 따라서 자바스크립트 엔진이 데이터 타입을 어떨 때 어떤 식으로 바꾸는지 이해할 필요가 있다.
*/


/** 
 * * 문자열 타입 변환
*/

10 + '' // '10'
var age = `your age? : ${23}` // 'your age : 23'

/** 
 * ? + 연산자는 더하기 연산자 이기도 하지만, 템플릿 연산자가 없던 ES6 이전 시절, 문자열들을 서로 이어주던, 고마운 문자열 연결 연산자 이기도 하다.
 * ? 자바스크립트 엔진은 이 + 연산자를 문자열 연결 우선자로 보고 피연산자중 하나라도 문자열 타입이 있을 경우,
 * ? 다른 피연산자도 문자열 타입으로 강제변환된다.
*/

/** 
 * ? ES6 에서 새로 생긴 백틱(`)을 사용한 문자열 템플릿을 통해 문자열 안에 변수를 사용하거나,
 * ? 표현식을 사용할 수 있게 됐고, 여기서도 문자열로 자동으로 타입 변환된다. 
 * TODO 그 외에 다른 타입도 모조리 문자열 타입으로 변환된다.
*/

0 + ''              // "0"
-0 + ''             // "0"
1 + ''              // "1"
-1 + ''             // "-1"
NaN + ''            // "NaN"
Infinity + ''       // "Infinity"
-Infinity + ''      // "-Infinity"
// 불리언 타입
true + ''           // "true"
false + ''          // "false"
// null 타입
null + ''           // "null"
// undefined 타입
undefined + ''      // "undefined"


/** 
 * * 숫자 타입 변환
*/

1 - '1' // 1
1 * '20' // 20
1 / '2' // 0.5 



/** 
 * ? +연산자를 제외한 나머지는 산술만을 위한 연산자 이므로 피연산자는 반드시 숫자 타입이어야 한다.
 * ? 그러기 때문에 숫자 타입이 아닌 피연산자는 숫자타입으로 변환된다.
 * ? 그러나 숫자 타입으로 변환할 수 없는 객체,문자열은 NaN이 반환된다.
 * ! 맘대로 쓰지 말장
*/

'1' > 0  // true
console.log('str' > 0); // false 

/** 
 * ? 상대적인 크기를 통해 boolean 값을 정하는 비교연산자 또한 숫자 타입으로 변경된다.
 * ? 숫자 타입으로 변경할 수 없는 경우는 표현식 값 false를 반환한다.
*/
