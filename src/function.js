
/**
 * * 함수 
 * ? 특정한 목적을 가지고 실행되는 문들의 모음. 
 * ? 매개변수와 코드 블록으로 이루어져 있으며, 필요한 때에 어디서든 호출할 수 있다.
 */

function hello() {
    console.log("Hello World!");
}

hello();

/**
 * * 함수의 장점
 * ? 어디서든지 쉽게 호출할 수 있고, 특정한 기능을 사용할 때마다 일일이 코딩할 필요 없이
 * ? 미리 정의해 자유롭게 꺼내다 쓸 수 있기 때문에, 재사용성 증가에 효과가 있다.
 */

/** 
 * * 함수의 활용
 * ? 자바스크립트에서 함수는 일급 객체로 취급되므로, 값으로써 사용될 수 있다.
 * ? 변수에 인자로 넘길 수도 있고 매개변수로 사용할 수도 있으며, 값을 저장할 수 있는 곳에는
 * ? 함수도 저장할 수 있다. 객체를 효율적으로 생성하는 생성자 함수 또한 "함수"다.
*/

/** 
 * * 함수를 정의하는 방식
 * ? 함수를 정의하는 방식은 3가지가 있다.
 * ! 함수 선언문
 * ! 함수 표현식
 * ! Function 생성자 함수
*/

/** 
 * ! 함수 선언문
 * ? 변수를 선언하듯이 function 함수를 선언하고 정의하는 방식. 정의에는 규칙이 있다.
 * ? 함수명은 절대로 생략할 수 없다.
 * ? 자바스크립트 디버거가 해당 함수를 식별할 수 있는 식별자 사용
 * ? 매개변수가 없더라도 ()를 사용해야 한다.
 * ? 결과값을 반환할 땐 return을 사용.
*/

function Warrior(weapon,hp) {
    this.weapon = weapon;
    this.hp = hp;
    this.equipment = {
        weapon : this.weapon,
        armor : 'cloth armor',
        accessories : {
            equip1 : 'ring',
            equip2 : 'necklace',
        }
    };
    this.character = () => { // ? 매개변수가 없을시 익명함수를 사용할 수 있다.
        console.log(this); // 자신의 정보를 호출 
    }
    this.weaponchange = () => {
        this.equipment.weapon = this.weapon;
    }  
    
}

const player = new Warrior('Wooden Sword','hp');

player.weapon = 'Sword';

player.weaponchange();

player.character();




function objtype(obj) { // ? obj 라는 매개변수를 이용해 특정한 기능을 수행 다른 언어와 달리 타입을 미리 정하지 않는다.
    const objProps = Object.getOwnPropertyNames(obj);

    objProps.forEach((name) => {
        console.log(name + ":" + typeof obj[name]);
    });
}

objtype(player);

/** 
 * ! 함수 표현식
 * ? 표현식은 하나의 값을 만드는 것이다, 일급 객체인 함수는 값으로써 사용될 수 있고,
 * ? 하나의 값을 만드는 표현식에서 또한 사용할 수 있다.
*/

var npc = function() {
    return console.log('Hello Warrior!');
}

/** 
 * ? 할당 또한 표현식이기 때문에 유효하다.
*/

npc();

/** 
 * ! 함수 표현식으로 정의한 함수는 함수명을 생략할 수 있습니다.
 * ! 생략하지 않아도 함수 이름이 아닌 변수 식별자를 통해 함수를 불러올 수 있습니다.
 * ! 익명함수는 또한 간단하게 표현할 수 있다. 일단 알고만 있자.
*/

var shop = () => {
    console.log('welcome');
}

shop();

/** 
 * ? 함수 선언문도 사실은 함수 표현식처럼 객체 리터럴 방식으로 정의된다.
 * ? 단순함을 추구하기 위해서 단축 시킨 듯 하다.
*/


/** 
 * ! Function 생성자 함수
 * ? 함수 선언문,함수 표현식은 자바스크립트 내장 함수인
 * ? Function 생성자 함수로 생성하는 것을 단순화한 축약식이다.
 * ? 그래서 이게 원본이나 축약시킨 이유가 괜히 있는 것이 아니니 사용하지 않는 걸 추천한다.
*/

var func = new Function('num1','num2','return console.log(num1+num2)');

func(1,2);

/** 
 * ! 사용을 자제하자 축약식이 두 개나 있다.
*/

/** 
 * * 함수 호이스팅
 * ? 변수 편에서 알아봤듯이 호이스팅은 모든 선언문의 스코프가 맨 선두로 올라가듯이
 * ? 작동하기 때문에 선언되기 이전에도 참조할 수 있는 특성을 말한다.
 * ? 그런데 함수를 어떻게 정의하냐에 따라 이 호이스팅에 동작 방식에 대한 차이점이 있다.
*/

hoisting("hello");

function hoisting(text) {
    return String.prototype.toUpperCase(text);
}

/** 
 * ? 함수 선언문의 경우 자바스크립트 엔진이 스크립트가 로딩되는 시점에
 * ? 함수 선언,초기화,할당이 한번에 이루어진다. 
 * ? 이루어 질 때는 VO(variable object)에 저장한다.
 * ? 한 번에 이루어진다는 건 선언 전에 호출을 해도, 그 과정이 한 번에 이루어졌기에
 * ? 위치와는 상관없이 호출이 가능하다.
*/

// ? var hoist = hosit(); // TypeError 발생

var hosit = function() {
    return 5;
}

/** 
 * ! 함수 표현식의 경우에는 변수에 값을 할당하는 것이기 때문에
 * ! 엄연히 변수 호이스팅이 발생한다. 
 * ! 호이스팅된 변수는 할당이 아닌 변수 등록과 초기화까지만 한번에  진행되므로
 * ! 참조할 때 undefined를 반환한다. 그러므로 선언이 안 된 객체를 넣었으니 TypeError가 날 수 밖에 없다.
*/

/** 
 * ? 함수 표현식은 변수 호이스팅으로 작동하기 때문에 VO에 저장되지 않고 
 * ? 자바스크립트 런타임에 의해서 변수 등록과 초기화만 이루어진다.
*/

/** 
 * * 함수 호이스팅의 단점
 * ? 함수 호이스팅은 함수의 규칙인 호출 전 반드시 선언되어야 한다는 규칙을 깨버린다.
 * ? 게다가 vo라는 객체에 저장된다는 의미는 메모리를 잡아먹는다는 뜻이므로,
 * ? 너무 남용되면 응답속도가 떨어질 수 있다.
 * TODO 함수 표현식 짱짱 권장
*/

/** 
 * * 일급 객체
 * ? 일급 객체가 되기 위한 조건은 4가지가 있다.
 * ? 무명의 리터럴로 표현이 가능하다.
 * ? 변수나 자료 구조(배열,객체)에 저장할 수 있다.
 * ? 함수의 매개변수에 전달할 수 있다.
 * ? 반환값으로 사용할 수 있다.
*/

/** 
 * TODO 1. 무명의 리터럴로 표현이 가능하다.
 * ? 자바스크립트 에는 함수 선언문을 제외한 표현식,값처럼 사용할 때
 * ? 익명함수로 사용할 수 있다. 함수 식별자를 정의할 필요가 없을 때 사용한다.
*/

var set = () => {
    return "name";
}

var set = function() {
    return "name";
} // 같은 변수명 사용시 재할당이 이루어진다.

// ? 익명함수일 경우 축약식으로 간단하게 표현 가능하고 두 개의 문을 똑같다.

/** 
 * TODO 2.변수나 자료구조(배열,객체)에 저장할 수 있다. 
 * ? 대표적으로 함수 표현식이 있고, 객체 내에서도 함수를 정의할 수 있고,
 * ? 대표적인 자료구조인 배열에도 언제든지 값처럼 사용할 수 있다.
*/

var arr = [];

arr = function name() {
    console.log("array");
}

console.log(arr);

/**
 * TODO 3.함수의 매개변수에 전달할 수 있다.
 * ? 값처럼 사용되는 일급 객체는 역시 매개변수로 사용할 수 있다.
 */


/** 
  * * 매개변수 (함수 인자)
  * ? 함수를 정의할 때 외부 데이터를 받아와 연산을 실행해야 하는 경우에 사용한다.
  * ? 함수 내에서 변수의 역할을 한다. 
 */

/** 
 * * 함수 인자
 * ? 실제 함수를 호출할 때 매개변수의 정의된 수만큼 인수를 할당하는데,
 * ? 함수 정의에 따라 인수를 넣지 않아도 에러는 나지 않는다. 적게 되면 나머지는 undefined 많게 되면 나머지는 무시당한다.
*/

/** 
 * ! 순수 함수 vs 비순수 함수
 * ? 함수문을 실행했을 때, 외부 변수나 객체를 변경하는 함수를 순수 함수,
 * ? 그렇지 않은 함수를 비순수 함수라고 한다. 예를 들어보자.
*/

var pure = "pure";

var impure = {
    nickname : 'impure',
    opposition : 'pure',
}

function change(one,two) {
    one += pure;
    impure.nickname = two;
}

change("hi","eva");

console.log(pure,impure);

/** 
 * ! 함수로 인해 impure 객체의 프로퍼티 값이 변경됐다. 객체는 불변성을 지니지 않고 참조값을 전달하기에 
 * ! 변경할 수 있다. 이렇게 내부 함수에 의해서 외부 값이 변경되는 걸 비순수 함수라고 한다.
 * ! pure값은 원시값이기에 복사값만을 넘기고 참조값은 넘기지 않아서 영향이 없다. 
*/

/** 
 * * 반환값 (return)
 * ? 함수는 특정한 기능을 실행하는 문들의 모임으로써, 값을 연산하거나 외부 변수의 값을 변경하는 비순수 함수로써
 * ? 기능할 수도 있고, 굉장히 복잡한 기능을 실행하기도 하지만, 값을 반환하는 경우도 있고 하지 않는 경우도 있다.
 * ? 이 때 값을 반환하기 위해 사용하는 키워드가 return 이다. 
 * ? reutrn 값은 하나가 아닐 수도 있따. 객체 일 수 있으며, 함수일 수도 있고, 배열일 수도 있다.
 * ! return 을 사용하면 해당 값을 반환하고 함수를 종료한다. return 뒤에 뭘 쓰지 말자. 실행 안 된다.
*/



// 기본 빌트인 객체중 getOwnPropertyNames -> 객체의 프로퍼티 키를 배열로 전환. 
// 을 한 번 구현해봐야지.

const getPropertyNames = (obj) => {
    const props = [];

    for (var keys in obj) {
        props.push(keys);
    }

    return props;
}

var data = getPropertyNames(player); // 구현 완료. 

console.log(data); // 잘 작동한다. 

/** 
 * ? 자바스크립트 자체 내장 객체인 Object의 내부 메서드인 getOwnPropertyNames() 을 흉내내 봤다.
 * ? 위의 함수는 객체의 프로퍼티 값을 배열 형태로 반환하는 역할을 한다. 이 때 return을 사용해서 값을 반환한 걸 알 수 있다.
*/

/** 
 * * 함수 객체의 프로퍼티
 * ? 함수도 객체이므로 프로퍼티 값을 가질 수 있다.
 * ? 굳이 함수에 프로퍼티를 붙이는 건 권장되지 않고, 함수는 자기만의 프로퍼티 값을 따로 갖고 있다.
 * ? 보이지 않지만 내부적으로 가지고 있다. 
*/

/** 
 * * argumennts (함수 인자) 
 * ? 호출할 때 받아온 외부 인자를 유사 배열 객체의 형태로 담고있는 내부 객체
 * ? 외부에서는 이 내부 객체를 사용할 수 없다. 
 * ? 함수 내부에서 지역 변수처럼 자유롭게 사용할 수 있다. 
 * TODO arguments 객체는 매개변수 수가 정해지지 않는 가변 인자 함수를 구현할때 굉장히 유용하다.
*/

var sum = () => {
    
}


